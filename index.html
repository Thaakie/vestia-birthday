<!DOCTYPE html>
<html lang="id">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Happy Birthday — Throw the Cake!</title>

    <!-- GSAP CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/MotionPathPlugin.min.js"></script>

    <style>
      :root {
        --bg: #fef5ff;
        --card: #fff9fc;
        --accent: #ff7aa2;
        --accent-2: #ffd166;
        --glass: rgba(255, 122, 162, 0.08);
        --glass-2: rgba(255, 122, 162, 0.05);
        --text: #2d1b3d;
        --muted: rgba(45, 27, 61, 0.55);
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: Inter, "Segoe UI", Roboto, system-ui, -apple-system, "Helvetica Neue", Arial;
        background: radial-gradient(1200px 600px at 10% 10%, rgba(255, 122, 162, 0.15), transparent), radial-gradient(800px 400px at 90% 90%, rgba(255, 209, 102, 0.12), transparent),
          radial-gradient(900px 500px at 50% 50%, rgba(167, 139, 250, 0.08), transparent), var(--bg);
        color: var(--text);
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        overflow-y: auto;
        perspective: 1200px;
        padding-bottom: 60px;
      }

      .wrap {
        max-width: 1100px;
        margin: 40px auto;
        padding: 36px;
        border-radius: 18px;
        background: rgba(255, 255, 255, 0.72);
        backdrop-filter: blur(12px);
        box-shadow: 0 10px 40px rgba(255, 122, 162, 0.15), 0 4px 12px rgba(255, 209, 102, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.8);
        border: 1px solid rgba(255, 255, 255, 0.6);
      }

      header {
        display: flex;
        gap: 24px;
        align-items: center;
        flex-wrap: wrap;
      }

      .photo {
        width: 260px;
        min-width: 200px;
        height: 260px;
        border-radius: 14px;
        overflow: hidden;
        flex-shrink: 0;
        transform-origin: center;
        box-shadow: 0 8px 30px rgba(255, 122, 162, 0.2);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.5), rgba(255, 240, 250, 0.3));
        border: 1px solid rgba(255, 255, 255, 0.8);
      }
      .photo img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }

      .gift-card {
        flex: 1;
        min-width: 260px;
        padding: 20px;
        border-radius: 12px;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(255, 240, 250, 0.7));
        border: 1px solid rgba(255, 255, 255, 0.8);
        box-shadow: 0 6px 20px rgba(255, 122, 162, 0.15);
      }
      .gift-card h1 {
        margin: 0 0 8px 0;
        font-size: 22px;
        letter-spacing: 0.6px;
        color: #c7365f;
      }
      .gift-card p {
        margin: 0 0 12px 0;
        color: rgba(45, 27, 61, 0.85);
        line-height: 1.45;
      }
      .scroll-hint {
        margin-top: 12px;
        font-size: 13px;
        color: var(--muted);
      }

      .content {
        margin-top: 28px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 28px;
      }
      .panel {
        padding: 24px;
        border-radius: 14px;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.8), rgba(255, 240, 250, 0.6));
        border: 1px solid rgba(255, 255, 255, 0.7);
        box-shadow: 0 4px 16px rgba(255, 122, 162, 0.1);
      }

      .celebrate {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 340px;
        position: relative;
        overflow: visible;
        /* fixed padding-bottom kept at 40px as requested */
        padding-bottom: 40px;
        gap: 16px;
      }

      .target-name {
        font-size: 56px;
        font-weight: 700;
        margin: 0;
        transform-style: preserve-3d;
        text-align: center;
        text-shadow: 0 4px 20px rgba(255, 122, 162, 0.3);
        padding: 18px 36px;
        border-radius: 12px;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(255, 240, 250, 0.8));
        border: 2px solid rgba(255, 122, 162, 0.2);
        display: inline-block;
        position: relative;
        z-index: 3;
        color: #c7365f;
      }
      .subtitle {
        margin-top: 10px;
        color: rgba(45, 27, 61, 0.7);
        font-size: 16px;
      }

      /* Glow animation for the target text */
      @keyframes nameGlow {
        0% {
          text-shadow: 0 4px 20px rgba(255, 122, 162, 0.3);
          transform: scale(1);
        }
        50% {
          text-shadow: 0 0 28px rgba(255, 122, 162, 0.95), 0 0 46px rgba(255, 209, 102, 0.6);
          transform: scale(1.02);
        }
        100% {
          text-shadow: 0 4px 20px rgba(255, 122, 162, 0.3);
          transform: scale(1);
        }
      }
      .target-name.glow {
        animation: nameGlow 1.1s ease both;
      }

      .cake {
        width: 140px;
        height: 120px;
        border-radius: 12px;
        position: relative;
        margin: 20px 0;
        z-index: 40;
        transform-style: preserve-3d;
        cursor: grab;
        user-select: none;
        will-change: transform, opacity;
        pointer-events: auto;
      }
      .cake .layer {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        width: 120px;
        height: 40px;
        border-radius: 14px;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.45);
        border: 2px solid rgba(0, 0, 0, 0.15);
      }
      .cake .layer.bottom {
        bottom: 6px;
        background: linear-gradient(180deg, #ffecd2, #ffd6a5);
        width: 140px;
        height: 44px;
        border-radius: 16px;
      }
      .cake .layer.middle {
        bottom: 48px;
        background: linear-gradient(180deg, #ffd6f0, #ff7aa2);
        width: 120px;
        height: 44px;
        border-radius: 14px;
      }
      .cake .layer.top {
        bottom: 88px;
        background: linear-gradient(180deg, #fff, #ffe7f2);
        width: 100px;
        height: 34px;
        border-radius: 12px;
      }
      .cake .frosting {
        position: absolute;
        bottom: 88px;
        left: 50%;
        transform: translateX(-50%) translateY(-8px);
        width: 100px;
        height: 12px;
        border-radius: 8px;
        background: linear-gradient(90deg, #ff7aa2, #ffd166);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.25);
      }
      .cake .candles {
        position: absolute;
        bottom: 120px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 6px;
      }
      .candle {
        width: 6px;
        height: 18px;
        background: linear-gradient(180deg, #e6e6e6, #9f4d66);
        border-radius: 3px;
        position: relative;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
      }
      .candle:before {
        content: "";
        position: absolute;
        top: -8px;
        left: 50%;
        transform: translateX(-50%);
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: radial-gradient(circle at 30% 30%, #fff, #ffd166);
      }

      .controls {
        display: flex;
        gap: 12px;
        align-items: center;
        z-index: 70;
        position: relative;
      }
      .btn {
        background: linear-gradient(90deg, var(--accent), #ff5fa8);
        padding: 12px 18px;
        border-radius: 12px;
        color: white;
        border: none;
        font-weight: 700;
        cursor: pointer;
        box-shadow: 0 10px 30px rgba(255, 122, 162, 0.12);
        transition: transform 0.12s ease;
      }
      .btn:active {
        transform: translateY(2px);
      }
      .secondary {
        background: rgba(255, 255, 255, 0.7);
        border: 1px solid rgba(255, 122, 162, 0.2);
        color: #c7365f;
        padding: 10px 12px;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.18s ease;
      }
      .secondary:hover {
        background: rgba(255, 255, 255, 0.9);
        border-color: rgba(255, 122, 162, 0.4);
      }

      #trailCanvas {
        position: fixed;
        left: 0;
        top: 0;
        width: 100vw;
        height: 100vh;
        pointer-events: none;
        z-index: 260;
        mix-blend-mode: screen;
      }
      #splatCanvas {
        position: fixed;
        left: 0;
        top: 0;
        width: 100vw;
        height: 100vh;
        pointer-events: none;
        z-index: 240;
        mix-blend-mode: normal;
      }

      .splat {
        position: fixed;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        pointer-events: none;
        z-index: 250;
        transform-origin: center;
        filter: blur(0.4px);
        mix-blend-mode: normal;
      }
      .confetti {
        position: fixed;
        width: 10px;
        height: 18px;
        z-index: 255;
        pointer-events: none;
        transform-origin: center;
        border-radius: 2px;
        opacity: 0.95;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.35);
      }

      .mini-sticker {
        position: absolute;
        right: -6px;
        top: -12px;
        width: 38px;
        height: 38px;
        border-radius: 10px;
        background: linear-gradient(180deg, #fff0, #fff);
        display: flex;
        align-items: center;
        justify-content: center;
        transform-origin: center;
        z-index: 40;
        pointer-events: none;
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.45);
        border: 1px solid rgba(255, 255, 255, 0.06);
        backdrop-filter: blur(4px);
      }
      .mini-sticker .mini-cake {
        width: 28px;
        height: 22px;
        border-radius: 6px;
        background: linear-gradient(180deg, #ffd6f0, #ff7aa2);
        box-shadow: inset 0 -6px 8px rgba(0, 0, 0, 0.08);
        position: relative;
      }
      .mini-sticker .mini-cake:after {
        content: "";
        position: absolute;
        left: 4px;
        right: 4px;
        top: -6px;
        height: 6px;
        border-radius: 4px;
        background: linear-gradient(90deg, #ff7aa2, #ffd166);
      }

      .memories-controls {
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
        margin-bottom: 12px;
      }
      .memories-gallery {
        display: flex;
        flex-wrap: wrap;
        gap: 18px;
        align-items: flex-start;
        justify-content: center; /* centered as requested */
      }
      /* bigger medium thumbnails and centered layout */
      .thumb {
        width: 220px;
        height: 150px;
        object-fit: cover;
        border-radius: 8px;
        position: relative;
        overflow: hidden;
        border: 1px solid rgba(0, 0, 0, 0.06);
        cursor: pointer;
        display: block;
      }
      .thumb-wrap {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .caption {
        margin-top: 8px;
        font-size: 13px;
        color: var(--muted);
        text-align: center;
        max-width: 240px;
        line-height: 1.2;
      }
      .thumb-actions {
        position: absolute;
        right: 6px;
        top: 6px;
        display: flex;
        gap: 6px;
      }
      .thumb button {
        background: rgba(255, 255, 255, 0.9);
        border: 1px solid rgba(0, 0, 0, 0.06);
        padding: 4px;
        border-radius: 6px;
        cursor: pointer;
      }

      /* --- MEMORY THUMBNAIL HOVER EFFECT (only changed part) --- */
      .thumb img {
        width: 100%;
        height: 100%;
        display: block;
        object-fit: cover;

        /* smooth hover effect */
        transition: transform 260ms cubic-bezier(0.2, 0.9, 0.2, 1), filter 220ms ease, box-shadow 260ms ease, opacity 200ms ease;
        will-change: transform, filter, box-shadow, opacity;
      }
      .thumb:hover img,
      .thumb:focus-within img {
        transform: translateY(-8px) scale(1.04);
        filter: brightness(1.04) saturate(1.06);
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.12);
        opacity: 1;
      }

      /* --- LIGHTBOX: refined centered non-fullscreen modal --- */
      .lightbox {
        position: fixed;
        left: 0;
        top: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.55);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        opacity: 0;
        pointer-events: none;
        transition: opacity 220ms ease;
      }
      .lightbox.open {
        opacity: 1;
        pointer-events: auto;
      }

      /* inner container centers and gives padding + rounded background */
      .lightbox .lightbox-inner {
        width: min(80vw, 1200px);
        max-width: 90vw;
        height: auto;
        max-height: 78vh;
        border-radius: 12px;
        overflow: hidden;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(0, 0, 0, 0.02));
        box-shadow: 0 30px 80px rgba(0, 0, 0, 0.6);
        transform: translateY(6px) scale(0.995);
        transition: transform 260ms cubic-bezier(0.2, 0.9, 0.2, 1), opacity 200ms ease;
        display: flex;
        flex-direction: column;
        align-items: stretch;
      }
      .lightbox.open .lightbox-inner {
        transform: translateY(0) scale(1);
      }

      .lightbox .lightbox-media {
        width: 100%;
        flex: 1 1 auto;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
      }

      .lightbox .lightbox-media img {
        max-width: 100%;
        max-height: 72vh;
        object-fit: contain;
        display: block;
        background: #000;
      }

      .lightbox .lightbox-footer {
        padding: 12px 16px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.02));
      }

      .lightbox .lb-caption {
        color: #fff;
        font-size: 14px;
        line-height: 1.2;
        opacity: 0.95;
        max-width: calc(100% - 140px);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .lightbox .lb-controls {
        display: flex;
        gap: 8px;
      }
      .lightbox .lb-btn {
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.08);
        color: white;
        padding: 8px 10px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
      }
      .lightbox .lb-btn:focus {
        outline: 2px solid rgba(255, 122, 162, 0.9);
        outline-offset: 2px;
      }

      .lightbox .lb-nav {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        width: 48px;
        height: 48px;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.45);
        color: white;
        border: none;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        z-index: 10005;
      }
      .lightbox .lb-prev {
        left: 24px;
      }
      .lightbox .lb-next {
        right: 24px;
      }

      /* close button style */
      .lightbox #lbClose {
        background: transparent;
        border: none;
        color: white;
        font-size: 22px;
        cursor: pointer;
        padding: 6px 8px;
      }

      footer {
        margin-top: 26px;
        text-align: center;
        color: rgba(45, 27, 61, 0.5);
        font-size: 13px;
      }

      @media (max-width: 820px) {
        .photo {
          width: 160px;
          height: 160px;
        }
        .target-name {
          font-size: 40px;
        }
        .cake {
          width: 110px;
          height: 95px;
        }
        .celebrate {
          padding-bottom: 40px;
        }
        .thumb {
          width: 160px;
          height: 120px;
        }
        .lightbox .lightbox-inner {
          max-width: 94vw;
          max-height: 78vh;
        }
        .lightbox .lb-caption {
          max-width: 65vw;
        }
      }
    </style>
  </head>
  <body>
    <!-- Background music and sound effects
         NOTE: Place actual audio files next to this HTML (or update the src URLs):
         - beabadoobee - Glue Song (Lyrics).mp3  -> background music file (ensure you have the rights)
         - bubble-sound-43207.mp3 -> click/pickup sound
         - computer-mouse-click-351398.mp3 -> impact sound
    -->
    <audio id="bgMusic" src="beabadoobee - Glue Song (Lyrics).mp3" loop preload="auto" crossorigin="anonymous"></audio>
    <audio id="sfxClick" src="bubble-sound-43207.mp3" preload="auto"></audio>
    <audio id="sfxPop" src="computer-mouse-click-351398.mp3" preload="auto"></audio>

    <canvas id="trailCanvas" aria-hidden="true"></canvas>
    <canvas id="splatCanvas" aria-hidden="true"></canvas>

    <div class="wrap" role="main">
      <header>
        <div class="photo" id="photo"><img src="cat.jpg" alt="Gift Photo" /></div>
        <div class="gift-card" id="giftCard">
          <h1>To Vestia — Kimberly Itzel</h1>
          <p>
            Selamat ulang tahun kamuu ;D Semoga kedepannya bisa menjadi dirimu yang kamu pengen yaa, jangan nyerah, terus semangatt untuk sekolahnyaa ;D, dan perihal kesibukan semoga diringankan lebih cepat, biar nda stress, thank you for
            being you with me ;DD
          </p>
          <p class="scroll-hint">Tip: The button is me throwing you a cake :)</p>
        </div>
      </header>

      <div class="content">
        <div class="panel celebrate" id="celebratePanel">
          <h2 class="target-name" id="targetName">Vestia — Kimberly Itzel</h2>
          <div class="subtitle" id="subtitle">Wishing you a day full of laughter, sprinkles, and everything bright ✨</div>

          <!-- cake template -->
          <div class="cake" id="cake" aria-hidden="true">
            <div class="layer bottom"></div>
            <div class="layer middle"></div>
            <div class="layer top"></div>
            <div class="frosting"></div>
            <div class="candles" aria-hidden="true">
              <div class="candle"></div>
              <div class="candle"></div>
              <div class="candle"></div>
            </div>
          </div>

          <div class="controls" role="group" aria-label="Cake controls">
            <button class="btn" id="throwBtn">Throw the Cake!</button>
            <button class="secondary" id="resetBtn" title="Reset splats">Clean screen</button>

            <!-- MUSIC TOGGLE ADDED (Play / Pause background music) -->
            <button class="secondary" id="musicToggle" aria-pressed="false" title="Play / Pause music">Play Music</button>
          </div>
        </div>

        <div class="panel">
          <h3>Gift Card</h3>
          <p>
            Dear Vestia — I hope this little web surprise brings a smile to your day.<br />
            May your year be filled with songs that move your heart,<br />
            friends who lift your spirit, and small victories that make you proud.<br />
            — From someone who cares ;D <br />
            <br />
            Another year, another glow — like petals that never fade.<br />
            May your heart stay light, your dreams stay bright,<br />
            and your journey feel like spring in every step.<br />
            Happy birthday, Vestia.
          </p>
        </div>

        <div class="panel">
          <h3>Memories</h3>

          <!-- STATIC gallery with 5 sample photos (click thumbnail to preview in lightbox).
               Each photo has a short caption below explaining the moment. -->
          <div class="memories-gallery" id="memoriesGallery" aria-live="polite" aria-label="Memories gallery">
            <div class="thumb-wrap">
              <div class="thumb"><img src="vestia1.png" alt="Memory 1" /></div>
              <div class="caption">wkwwkwkk ternyata aku ada foto ini ;D.</div>
            </div>

            <div class="thumb-wrap">
              <div class="thumb"><img src="vestia2.png" alt="Memory 2" /></div>
              <div class="caption">kalau gak salah ini yang dari ichi yaa?.</div>
            </div>

            <div class="thumb-wrap">
              <div class="thumb"><img src="vestia3.jpg" alt="Memory 3" /></div>
              <div class="caption">maaf aku taruh ini, kegunaanya buat hal ini kok ;D.</div>
            </div>

            <div class="thumb-wrap">
              <div class="thumb"><img src="parahbanget.jpg" alt="Memory 4" /></div>
              <div class="caption">ini yang kelewatan itu wkwk, tapi lucu ajaa.</div>
            </div>

            <div class="thumb-wrap">
              <div class="thumb"><img src="kucingg1.jpg"Memory 5" /></div>
              <div class="caption">selipin dehh 1 ;D.</div>
            </div>
          </div>
        </div>
      </div>

      <footer>Made by kiee — throw responsibly ;()</footer>
    </div>

    <!-- lightbox -->
    <div id="lightbox" class="lightbox" role="dialog" aria-modal="true" aria-hidden="true">
      <button id="lbClose" aria-label="Close">✕</button>

      <!-- inner container -->
      <div class="lightbox-inner" role="document" aria-hidden="true">
        <!-- optional left/right nav (visible on hover/desktop) -->
        <button class="lb-nav lb-prev" aria-label="Previous image" title="Previous">◀</button>
        <div class="lightbox-media" aria-live="polite">
          <img id="lightboxImg" src="" alt="Full photo" />
        </div>
        <button class="lb-nav lb-next" aria-label="Next image" title="Next">▶</button>

        <div class="lightbox-footer">
          <div class="lb-caption" id="lbCaption"></div>
          <div class="lb-controls">
            <button class="lb-btn" id="lbPrevBtn" aria-label="Previous">Prev</button>
            <button class="lb-btn" id="lbNextBtn" aria-label="Next">Next</button>
            <button class="lb-btn" id="lbCloseBtn" aria-label="Close">Close</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      // Register GSAP plugin
      gsap.registerPlugin(MotionPathPlugin);

      // Elements
      const throwBtn = document.getElementById("throwBtn");
      const resetBtn = document.getElementById("resetBtn");
      const cakeTemplate = document.getElementById("cake");
      const targetName = document.getElementById("targetName");
      const celebratePanel = document.getElementById("celebratePanel");
      const splatCanvas = document.getElementById("splatCanvas");
      const trailCanvas = document.getElementById("trailCanvas");
      const splatCtx = splatCanvas.getContext("2d");
      const trailCtx = trailCanvas.getContext("2d");

      // Audio elements (background + sfx)
      const bgMusic = document.getElementById("bgMusic");
      const sfxClick = document.getElementById("sfxClick");
      const sfxPop = document.getElementById("sfxPop");

      // Music toggle button
      const musicToggle = document.getElementById("musicToggle");

      // Memories elements
      const memoriesGallery = document.getElementById("memoriesGallery");

      // Track whether we've started background music (play once on first user gesture)
      let musicStarted = false;

      // Play SFX helper that supports overlapping/spam by cloning the element
      function playSfx(audioEl, opts = {}) {
        if (!audioEl) return;
        try {
          // cloneNode(true) copies the src and attributes — allows multiple concurrent plays
          const clone = audioEl.cloneNode(true);
          clone.preload = "auto";
          if (typeof opts.volume === "number") clone.volume = opts.volume;
          // Append to DOM briefly to increase chance of playback in some browsers (optional)
          clone.style.display = "none";
          document.body.appendChild(clone);
          // Reset time and play
          clone.currentTime = 0;
          const p = clone.play();
          // Remove clone after it ends (or after a timeout fallback)
          const cleanup = () => {
            try {
              clone.remove();
            } catch (e) {}
          };
          if (p && p.then) {
            p.then(() => {
              clone.addEventListener("ended", cleanup, { once: true });
            }).catch(() => {
              // fallback: schedule removal
              setTimeout(cleanup, 1200);
            });
          } else {
            // old browsers
            setTimeout(cleanup, 1200);
          }
        } catch (e) {
          // final fallback: try to replay original
          try {
            audioEl.currentTime = 0;
            audioEl.play().catch(() => {});
          } catch (err) {}
        }
      }

      // helper to try to start background music on a user gesture
      async function tryStartMusic() {
        if (musicStarted) return;
        if (!bgMusic) return;
        // Use the robust WebAudio background player first (if available)
        try {
          await playBackground();
          musicStarted = true;
          return;
        } catch (e) {
          // fallback to media element play
        }
        // try reload and play to overcome some stale states
        try {
          bgMusic.load();
        } catch (e) {}
        bgMusic.volume = 0.55;
        bgMusic.muted = false;
        bgMusic
          .play()
          .then(() => {
            musicStarted = true;
            // update toggle UI
            if (musicToggle) {
              musicToggle.textContent = "Pause Music";
              musicToggle.setAttribute("aria-pressed", "true");
            }
          })
          .catch((err) => {
            // couldn't autoplay even on gesture — that's okay, user can use the toggle
            console.warn("bgMusic play blocked", err);
          });
      }

      // START: Robust background music via WebAudio
      // WebAudio variables for background music
      let bgAudioCtx = null;
      let bgBuffer = null;
      let bgSourceNode = null;
      let bgGainNode = null;
      let bgPlayingViaBuffer = false;

      // load & decode background music into an AudioBuffer (call early)
      async function initBgBuffer() {
        if (bgBuffer || !bgMusic || !bgMusic.src) return;
        try {
          bgAudioCtx = bgAudioCtx || new (window.AudioContext || window.webkitAudioContext)();

          // Build a safe absolute URL and encode it to avoid server redirects / incorrect requests
          const rawSrc = bgMusic.getAttribute("src") || bgMusic.src || "";
          const absolute = new URL(rawSrc, location.href).href;
          const fetchUrl = encodeURI(absolute);

          // fetch the mp3/ogg file bytes (same-origin or CORS-enabled)
          const resp = await fetch(fetchUrl, { cache: "reload" });

          // If server responds with a content-disposition attachment or non-audio type, do not attempt decode
          const contentDisposition = resp.headers.get("content-disposition") || "";
          const contentType = (resp.headers.get("content-type") || "").toLowerCase();

          if (!resp.ok) throw new Error("bg fetch " + resp.status);
          if (contentDisposition.toLowerCase().includes("attachment") || !contentType.startsWith("audio/")) {
            // server forces download or returns non-audio — fallback to media element approach
            console.warn("Server returned non-audio or 'attachment' disposition — will use media element fallback. content-disposition:", contentDisposition, "content-type:", contentType);
            bgBuffer = null;
            return;
          }

          const arr = await resp.arrayBuffer();
          bgBuffer = await bgAudioCtx.decodeAudioData(arr);
          // decoded successfully
        } catch (err) {
          console.warn("initBgBuffer failed, will fallback to media element:", err);
          bgBuffer = null;
        }
      }

      // start the decoded buffer as a looping background track
      function startBgBuffer() {
        if (!bgBuffer) return false;
        if (!bgAudioCtx) bgAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
        // ensure context is resumed
        if (bgAudioCtx.state === "suspended") {
          bgAudioCtx.resume().catch(() => {});
        }
        // create nodes
        bgSourceNode = bgAudioCtx.createBufferSource();
        bgSourceNode.buffer = bgBuffer;
        bgSourceNode.loop = true;
        bgGainNode = bgAudioCtx.createGain();
        bgGainNode.gain.value = 0.55;
        bgSourceNode.connect(bgGainNode).connect(bgAudioCtx.destination);
        // start now
        bgSourceNode.start(0);
        bgPlayingViaBuffer = true;
        return true;
      }

      // stop the buffer playback
      function stopBgBuffer() {
        try {
          if (bgSourceNode) {
            bgSourceNode.stop();
            bgSourceNode.disconnect();
            bgSourceNode = null;
          }
        } catch (e) {
          /* ignore */
        }
        bgPlayingViaBuffer = false;
      }

      // Unified start function: tries WebAudio buffer first, falls back to media element
      async function playBackground() {
        // try WebAudio path
        if (!bgBuffer) {
          await initBgBuffer();
        }
        if (bgBuffer) {
          const ok = startBgBuffer();
          if (ok) return;
        }
        // fallback: try media element (requires user gesture)
        try {
          bgMusic.muted = false;
          bgMusic.volume = 0.55;
          await bgMusic.play();
        } catch (err) {
          console.warn("fallback bgMusic.play failed", err);
        }
      }

      // Unified stop
      function stopBackground() {
        if (bgPlayingViaBuffer) {
          stopBgBuffer();
        } else {
          try {
            bgMusic.pause();
          } catch (e) {}
        }
      }

      // Initialize BG buffer early (pre-decode) to improve responsiveness when user clicks toggle
      initBgBuffer().catch(() => {});
      // END: Robust background music via WebAudio

      // Wire the visible music toggle (user requested visible control)
      if (musicToggle) {
        // reflect initial state
        musicToggle.textContent = bgMusic && !bgMusic.paused ? "Pause Music" : "Play Music";
        musicToggle.setAttribute("aria-pressed", bgMusic && !bgMusic.paused ? "true" : "false");

        musicToggle.addEventListener("click", async () => {
          // if background is currently playing via buffer or media element, pause it.
          const currentlyPlaying = bgPlayingViaBuffer || (!bgMusic.paused && !bgMusic.ended && bgMusic.currentTime > 0);
          if (currentlyPlaying) {
            stopBackground();
            musicToggle.textContent = "Play Music";
            musicToggle.setAttribute("aria-pressed", "false");
            return;
          }
          // user gesture: resume any suspended contexts and play
          if (bgAudioCtx && bgAudioCtx.state === "suspended") {
            try {
              await bgAudioCtx.resume();
            } catch (e) {}
          }
          await playBackground();
          musicToggle.textContent = "Pause Music";
          musicToggle.setAttribute("aria-pressed", "true");
        });

        // update toggle text if user pauses/plays via other means
        if (bgMusic) {
          bgMusic.addEventListener("pause", () => {
            musicToggle.textContent = "Play Music";
            musicToggle.setAttribute("aria-pressed", "false");
          });
          bgMusic.addEventListener("play", () => {
            musicToggle.textContent = "Pause Music";
            musicToggle.setAttribute("aria-pressed", "true");
          });
        }
      }

      // Resize canvases (handle DPR)
      function resizeCanvas(canvas, ctx) {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.round(window.innerWidth * dpr);
        canvas.height = Math.round(window.innerHeight * dpr);
        canvas.style.width = window.innerWidth + "px";
        canvas.style.height = window.innerHeight + "px";
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
      }
      function resizeAll() {
        resizeCanvas(splatCanvas, splatCtx);
        resizeCanvas(trailCanvas, trailCtx);
        // fixed spacing: always 40px as requested
        celebratePanel.style.paddingBottom = "40px";
      }
      window.addEventListener("resize", resizeAll);
      resizeAll();

      // Basic reveals
      gsap.from("#photo", { duration: 1.1, y: 40, opacity: 0, ease: "power3.out" });
      gsap.from(".gift-card", { duration: 1.1, y: 40, opacity: 0, delay: 0.1, ease: "power3.out" });
      gsap.from(".panel", { duration: 1.1, y: 20, opacity: 0, stagger: 0.08, ease: "power3.out", delay: 0.05 });

      gsap.to(cakeTemplate, { y: -10, duration: 2.4, yoyo: true, repeat: -1, ease: "sine.inOut" });
      gsap.to(cakeTemplate, { rotationY: 6, rotationX: 4, duration: 3.2, yoyo: true, repeat: -1, ease: "sine.inOut", overwrite: true });

      // Utility: center of element in client coords
      function centerOf(el) {
        const r = el.getBoundingClientRect();
        return { clientX: r.left + r.width / 2, clientY: r.top + r.height / 2, rect: r };
      }

      // --------- Splats & trail ----------
      function drawBlob(ctx, cx, cy, radius, spikes, rotation, color, alpha) {
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = color;
        ctx.beginPath();
        const step = (Math.PI * 2) / spikes;
        for (let i = 0; i < spikes; i++) {
          const angle = i * step + rotation;
          const r1 = radius * (0.4 + Math.random() * 0.6);
          const r2 = radius * (0.7 + Math.random() * 0.6);
          const x1 = cx + Math.cos(angle) * r1;
          const y1 = cy + Math.sin(angle) * r1;
          const x2 = cx + Math.cos(angle + step * 0.5) * r2;
          const y2 = cy + Math.sin(angle + step * 0.5) * r2;
          if (i === 0) ctx.moveTo(x1, y1);
          ctx.quadraticCurveTo(x2, y2, x1, y1);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }

      function drawSplats(clientX, clientY, options = {}) {
        options = Object.assign({ count: 8, maxRadius: 90, palette: ["#ff7aa2", "#ffd166", "#7afcff", "#a3ffa6", "#ffd1ff"] }, options);
        for (let i = 0; i < options.count; i++) {
          const color = options.palette[Math.floor(Math.random() * options.palette.length)];
          const r = Math.random() * options.maxRadius * 0.8 + 12;
          const spikes = Math.floor(Math.random() * 6) + 3;
          const rot = Math.random() * Math.PI * 2;
          drawBlob(splatCtx, clientX + (Math.random() * 160 - 80), clientY + (Math.random() * 80 - 40), r, spikes, rot, color, Math.random() * 0.55 + 0.45);
        }
      }

      function spawnDomSplats(clientX, clientY) {
        const colors = ["#ff7aa2", "#ffd166", "#7afcff", "#a3ffa6", "#ffd1ff", "#ffd7e0"];
        for (let i = 0; i < 10; i++) {
          const s = document.createElement("div");
          s.className = "splat";
          const size = 18 + Math.random() * 70;
          s.style.width = size + "px";
          s.style.height = size * 0.6 + "px";
          s.style.left = clientX + (Math.random() * 140 - 70) + "px";
          s.style.top = clientY + (Math.random() * 80 - 40) + "px";
          s.style.borderRadius = 30 + Math.random() * 60 + "%";
          s.style.background = colors[Math.floor(Math.random() * colors.length)];
          s.style.opacity = 0.95;
          s.style.transform = `rotate(${Math.random() * 360}deg) scale(${0.4 + Math.random() * 1.1})`;
          s.style.filter = "blur(" + Math.random() * 1.2 + "px)";
          document.body.appendChild(s);
          gsap.fromTo(
            s,
            { scale: 0.2, y: -12, opacity: 0 },
            {
              duration: 0.9 + Math.random() * 0.8,
              scale: 1,
              y: 6 + Math.random() * 30,
              opacity: 0.95,
              ease: "back.out(1.4)",
              onComplete: () => {
                gsap.to(s, { delay: 1.2 + Math.random() * 0.6, opacity: 0, scale: 1.2, duration: 0.9, onComplete: () => s.remove() });
              },
            }
          );
        }
        for (let i = 0; i < 16; i++) {
          const c = document.createElement("div");
          c.className = "confetti";
          c.style.left = clientX + (Math.random() * 200 - 100) + "px";
          c.style.top = clientY + (Math.random() * 100 - 50) + "px";
          c.style.width = 6 + Math.random() * 12 + "px";
          c.style.height = 10 + Math.random() * 20 + "px";
          c.style.background = colors[Math.floor(Math.random() * colors.length)];
          c.style.transform = `rotate(${Math.random() * 360}deg)`;
          document.body.appendChild(c);
          gsap.to(c, { duration: 1.6 + Math.random() * 1.4, y: 220 + Math.random() * 600, x: Math.random() * 400 - 200, rotation: Math.random() * 1080 - 540, ease: "power2.in", opacity: 0, onComplete: () => c.remove() });
        }
      }

      function attachStickerToTarget() {
        const existing = targetName.querySelector(".mini-sticker");
        if (existing) existing.remove();
        const sticker = document.createElement("div");
        sticker.className = "mini-sticker";
        sticker.innerHTML = '<div class="mini-cake" aria-hidden="true"></div>';
        targetName.appendChild(sticker);
        gsap.fromTo(sticker, { scale: 0, rotation: -30, opacity: 0 }, { scale: 1, rotation: 0, opacity: 1, duration: 0.45, ease: "back.out(1.4)" });
        gsap.to(sticker, { rotation: 6, duration: 0.22, yoyo: true, repeat: 3, ease: "sine.inOut", delay: 0.2 });
        gsap.to(sticker, { delay: 3.2, duration: 0.9, y: -40, x: 40, rotation: 30, opacity: 0, ease: "power2.in", onComplete: () => sticker.remove() });
      }

      function onCakeImpact(clientX, clientY) {
        drawSplats(clientX, clientY, { count: 9 + Math.floor(Math.random() * 7), maxRadius: 110 });
        spawnDomSplats(clientX, clientY);

        // play impact pop sound (overlapping supported)
        playSfx(sfxPop, { volume: 0.9 });

        // add glowing class to the target name for a pulse effect
        targetName.classList.add("glow");
        // remove it after animation completes
        setTimeout(() => {
          targetName.classList.remove("glow");
        }, 1200);

        gsap.fromTo(
          targetName,
          { y: 0, rotation: 0 },
          {
            duration: 0.9,
            y: -6,
            rotation: 2,
            ease: "elastic.out(1,0.6)",
            onComplete() {
              gsap.to(targetName, { duration: 0.45, rotation: 0, y: 0 });
            },
          }
        );
        gsap.fromTo("#subtitle", { scale: 1, opacity: 1 }, { duration: 0.6, scale: 1.02, opacity: 0.95, yoyo: true, repeat: 1, ease: "power1.out" });
        const overlay = document.createElement("div");
        overlay.style.position = "fixed";
        overlay.style.left = 0;
        overlay.style.top = 0;
        overlay.style.width = "100%";
        overlay.style.height = "100%";
        overlay.style.zIndex = 285;
        overlay.style.pointerEvents = "none";
        overlay.style.background = "radial-gradient(circle at " + (clientX / window.innerWidth) * 100 + "% " + (clientY / window.innerHeight) * 100 + "%, rgba(255,250,240,0.12), rgba(0,0,0,0))";
        document.body.appendChild(overlay);
        gsap.to(overlay, { opacity: 0, duration: 1.2, ease: "power2.out", onComplete: () => overlay.remove() });

        attachStickerToTarget();
      }

      // --------- Throwing logic (clones fixed positioned) ----------
      const activeCakes = [];
      const maxActive = 8;
      let trailPoints = [],
        maxTrailPoints = 140;

      function pushTrail(x, y) {
        trailPoints.push({ x, y, life: 1 });
        if (trailPoints.length > maxTrailPoints) trailPoints.splice(0, trailPoints.length - maxTrailPoints);
      }

      function drawTrail() {
        trailCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
        for (let i = 0; i < trailPoints.length; i++) {
          const p = trailPoints[i];
          trailCtx.globalAlpha = Math.max(0, p.life * 0.9);
          const size = 4 + (1 - p.life) * 8;
          trailCtx.fillStyle = `rgba(255,197,235,${0.5 * p.life})`;
          trailCtx.beginPath();
          trailCtx.arc(p.x, p.y, size, 0, Math.PI * 2);
          trailCtx.fill();
        }
        for (let p of trailPoints) p.life -= 0.018;
        if (trailPoints.length && trailPoints[0].life <= 0) trailPoints.shift();
        requestAnimationFrame(drawTrail);
      }
      requestAnimationFrame(drawTrail);

      function throwCake() {
        if (activeCakes.length >= maxActive) {
          gsap.fromTo(throwBtn, { scale: 1 }, { scale: 0.96, duration: 0.08, yoyo: true, repeat: 1 });
          return;
        }

        // play pickup/click sound (overlapping supported) and start music on first user interaction
        playSfx(sfxClick, { volume: 0.9 });
        tryStartMusic();

        // clone
        const cake = cakeTemplate.cloneNode(true);
        cake.style.position = "fixed";
        cake.style.pointerEvents = "none";
        cake.style.left = "0px";
        cake.style.top = "0px";
        cake.style.zIndex = 300;
        document.body.appendChild(cake);
        activeCakes.push(cake);

        const srcRect = cakeTemplate.getBoundingClientRect();
        const start = { x: srcRect.left + srcRect.width / 2, y: srcRect.top + srcRect.height / 2 };
        gsap.set(cake, { x: start.x, y: start.y, xPercent: -50, yPercent: -50, transformOrigin: "50% 50%" });
        const t = centerOf(targetName);
        const end = { x: t.clientX + (Math.random() * 36 - 18), y: t.clientY + (Math.random() * 26 - 12) };
        const midX = (start.x + end.x) / 2 + (Math.random() * 220 - 110);
        const midY = Math.min(start.y, end.y) - (120 + Math.random() * 180);
        const duration = 0.95 + Math.random() * 0.5;
        const getTranslate = gsap.getProperty(cake);

        gsap.to(cake, {
          duration,
          ease: "power2.in",
          motionPath: {
            path: [
              { x: start.x, y: start.y },
              { x: midX, y: midY },
              { x: end.x, y: end.y },
            ],
            curviness: 1.2,
            autoRotate: false,
            align: false,
          },
          onStart() {
            gsap.fromTo(cake, { scale: 0.72, opacity: 0.98 }, { duration: 0.26, scale: 1, opacity: 1, ease: "back.out(1.2)" });
          },
          onUpdate() {
            const x = parseFloat(getTranslate("x")),
              y = parseFloat(getTranslate("y"));
            pushTrail(x, y);
          },
          onComplete() {
            const x = end.x,
              y = end.y;
            gsap.to(cake, { scale: 1.04, rotation: -10, duration: 0.12, yoyo: true, repeat: 1, ease: "power1.out" });
            onCakeImpact(x, y);
            gsap.to(cake, {
              opacity: 0,
              duration: 0.9,
              delay: 0.6,
              onComplete: () => {
                cake.remove();
                const idx = activeCakes.indexOf(cake);
                if (idx !== -1) activeCakes.splice(idx, 1);
              },
            });
          },
        });
        gsap.to(cake, { duration: duration, rotationY: 360 * (Math.random() > 0.5 ? 1 : -1), rotationX: Math.random() * 30 - 12, ease: "none" });
      }

      // reset splats — animate out instead of immediate clear
      function clearSplatScreen() {
        // animate DOM splats and confetti (staggered)
        const domEls = Array.from(document.querySelectorAll(".splat, .confetti"));
        if (domEls.length) {
          domEls.forEach((el, i) => {
            gsap.to(el, {
              duration: 0.48,
              opacity: 0,
              scale: 0.6,
              y: -30,
              rotation: Math.random() * 120 - 60,
              ease: "power2.in",
              delay: i * 0.02,
              onComplete: () => el.remove(),
            });
          });
        }
        // fade out canvases, then clear, then fade them back in
        gsap.to([splatCanvas, trailCanvas], {
          duration: 0.5,
          opacity: 0,
          ease: "power2.in",
          onComplete() {
            // clear drawing buffers
            splatCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
            trailCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);
            trailPoints = [];
            // fade back in quickly to be ready for more drawing
            gsap.to([splatCanvas, trailCanvas], { duration: 0.35, opacity: 1, ease: "power2.out", delay: 0.06 });
          },
        });
      }

      // Button handlers
      throwBtn.addEventListener("click", () => {
        throwCake();
        if (navigator.vibrate) navigator.vibrate(30);
      });
      resetBtn.addEventListener("click", clearSplatScreen);
      throwBtn.addEventListener("keyup", (e) => {
        if (e.key === "Enter" || e.key === " ") throwCake();
      });

      // click on name throws a cake too
      targetName.addEventListener("click", () => {
        throwCake();
        gsap.to(targetName, { scale: 1.03, duration: 0.12, yoyo: true, repeat: 1, ease: "power1.out" });
      });

      // intersection reveal for panels
      const panels = document.querySelectorAll(".panel");
      const obs = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              gsap.to(entry.target, { opacity: 1, y: 0, duration: 0.8, ease: "power3.out" });
              obs.unobserve(entry.target);
            }
          });
        },
        { threshold: 0.16 }
      );
      panels.forEach((p) => {
        gsap.set(p, { opacity: 0, y: 14 });
        obs.observe(p);
      });

      // initial burst
      window.addEventListener("load", () => {
        const t = centerOf(targetName);
        setTimeout(() => {
          drawSplats(t.clientX, t.clientY, { count: 6, maxRadius: 60 });
          spawnDomSplats(t.clientX, t.clientY);
        }, 900);
        // ensure fixed padding is present after load
        celebratePanel.style.paddingBottom = "40px";
      });

      // DPR watcher
      let lastDpr = window.devicePixelRatio;
      const dprWatcher = setInterval(() => {
        if (window.devicePixelRatio !== lastDpr) {
          lastDpr = window.devicePixelRatio;
          resizeAll();
        }
      }, 800);
      window.addEventListener("beforeunload", () => clearInterval(dprWatcher));

      // ---------- REFINED CENTERED LIGHTBOX BEHAVIOR (REPLACES previous lightbox wiring) ----------
      (function initLightbox() {
        const lightboxEl = document.getElementById("lightbox");
        const inner = lightboxEl.querySelector(".lightbox-inner");
        const mediaImg = document.getElementById("lightboxImg");
        const captionEl = document.getElementById("lbCaption");
        const btnClose = document.getElementById("lbClose");
        const btnCloseFooter = document.getElementById("lbCloseBtn");
        const btnPrev = document.querySelector(".lb-prev");
        const btnNext = document.querySelector(".lb-next");
        const btnPrevFooter = document.getElementById("lbPrevBtn");
        const btnNextFooter = document.getElementById("lbNextBtn");

        // gather sources + captions
        const thumbs = Array.from(document.querySelectorAll("#memoriesGallery .thumb img"));
        const captions = Array.from(document.querySelectorAll("#memoriesGallery .caption")).map((c) => c.textContent || "");
        const sources = thumbs.map((t) => t.src);

        let currentIndex = 0;
        let lastFocused = null;

        function show(index) {
          if (index < 0) index = sources.length - 1;
          if (index >= sources.length) index = 0;
          currentIndex = index;
          mediaImg.src = sources[currentIndex];
          mediaImg.alt = captions[currentIndex] || "Photo";
          captionEl.textContent = captions[currentIndex] || "";
          lightboxEl.classList.add("open");
          inner.setAttribute("aria-hidden", "false");
          lightboxEl.setAttribute("aria-hidden", "false");

          // small entrance animation via GSAP (subtle)
          gsap.fromTo(inner, { opacity: 0, scale: 0.985, y: 8 }, { duration: 0.28, opacity: 1, scale: 1, y: 0, ease: "power2.out" });

          // accessibility: trap focus
          lastFocused = document.activeElement;
          btnClose.focus();
          document.addEventListener("focus", trapFocus, true);
        }

        function hide() {
          lightboxEl.classList.remove("open");
          inner.setAttribute("aria-hidden", "true");
          lightboxEl.setAttribute("aria-hidden", "true");
          mediaImg.src = "";
          captionEl.textContent = "";
          document.removeEventListener("focus", trapFocus, true);
          if (lastFocused && typeof lastFocused.focus === "function") lastFocused.focus();
        }

        function prev() {
          show((currentIndex - 1 + sources.length) % sources.length);
        }
        function next() {
          show((currentIndex + 1) % sources.length);
        }

        // keyboard navigation
        function onKey(e) {
          if (lightboxEl.classList.contains("open")) {
            if (e.key === "Escape") {
              e.preventDefault();
              hide();
            } else if (e.key === "ArrowLeft") {
              e.preventDefault();
              prev();
            } else if (e.key === "ArrowRight") {
              e.preventDefault();
              next();
            }
          }
        }
        document.addEventListener("keydown", onKey);

        // trap tab focus inside the lightbox when open
        function trapFocus(e) {
          if (!lightboxEl.classList.contains("open")) return;
          if (!inner.contains(e.target)) {
            e.stopPropagation();
            btnClose.focus();
          }
        }

        // click handlers
        btnClose.addEventListener("click", hide);
        btnCloseFooter && btnCloseFooter.addEventListener("click", hide);
        btnPrev && btnPrev.addEventListener("click", prev);
        btnNext && btnNext.addEventListener("click", next);
        btnPrevFooter && btnPrevFooter.addEventListener("click", prev);
        btnNextFooter && btnNextFooter.addEventListener("click", next);

        // clicking outside inner closes
        lightboxEl.addEventListener("click", (e) => {
          if (e.target === lightboxEl) hide();
        });

        // swipe support (basic)
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoved = false;
        inner.addEventListener("touchstart", (ev) => {
          if (!ev.touches || !ev.touches[0]) return;
          touchStartX = ev.touches[0].clientX;
          touchStartY = ev.touches[0].clientY;
          touchMoved = false;
        });
        inner.addEventListener("touchmove", (ev) => {
          touchMoved = true;
        });
        inner.addEventListener("touchend", (ev) => {
          if (!touchMoved || !ev.changedTouches || !ev.changedTouches[0]) return;
          const dx = ev.changedTouches[0].clientX - touchStartX;
          const dy = ev.changedTouches[0].clientY - touchStartY;
          if (Math.abs(dx) > 40 && Math.abs(dx) > Math.abs(dy)) {
            if (dx > 0) prev();
            else next();
          }
        });

        // wire thumbnails to open refined lightbox
        thumbs.forEach((img, i) => {
          img.style.cursor = "zoom-in";
          img.addEventListener("click", () => {
            show(i);
          });
          // allow keyboard activation
          img.setAttribute("tabindex", "0");
          img.addEventListener("keydown", (e) => {
            if (e.key === "Enter" || e.key === " ") {
              e.preventDefault();
              show(i);
            }
          });
        });

        // expose for debugging if needed
        window.__refinedLightbox = { show, hide, next, prev };
      })();
      // ---------- end refined lightbox ----------
    </script>
  </body>
</html>
